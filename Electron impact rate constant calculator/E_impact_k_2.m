%------- Calculation of Crossections --------%
C_S=Cross;
a = 0.5;
b = 0;% set by kozak
E_Td=3100;
E1 = [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21]';
% Initially E_Vn defined without zeroth level energy
E_Vn =[0.291263	0.579434	0.864512	1.1465	1.42539	1.70119	1.9739	2.24352	2.51005	2.77348	3.03382	3.29107	3.54523	3.79629	4.04426	4.28914	4.53093	4.76962	5.00523	5.23774	5.46716]; 
Vn = zeros(size(E1,1)-2,size(E1,1)-2);
C = sqrt(1.6E-19/9.11E-31);
for i=1:size(E1)
for j=i+1:size(E1,1)+1
    if j<23
    Vn(j-1,i)=E1(j); %Possible transitions 
    end
end
end
E1=E1';
%Vn=vertcat(E1(1:end-1),Vn)
dE=zeros(size(Vn,1),size(Vn,2));
for n=1:size(Vn,1)
    for m=1:size(Vn,2)
        if Vn(m,n)>0
    dE(m,n) = Vn(m,n)-E1(n)-1; %Possible transition energy differencenses in terms of mn
        end
    end
end   
EXP  = exp(-a.*dE); % Exponential decay of the crossection
E_mn = zeros(size(E_Vn,1)-2,size(E_Vn,1)-2);
E_mn_ev = zeros(size(E_Vn,1)-2,size(E_Vn,1)-2);
for n=1:size(Vn,1)
for m=1:size(Vn,2)
    if Vn(m,n)>0
    E_mn(m,n)=E_Vn(m); % Energy levels of the states (ev)
    end
end
end
E_Vn =[0 E_Vn]; % Redefined E_Vn for energy calculation
E_0=0;
E_01=E_Vn(2);
for n=1:size(E_mn,1)
    for m=1:size(E_mn,2)
        if E_mn(m,n)>0
     E_mn_ev(m,n) = (E_mn(m,n)-E_Vn(n)); %Possible transition energy differencenses in terms of eV
        end
    end
end   
x_axis = C_S(:,1);
y_axis = C_S(:,2);
x_axises=[];
for n=1:size(E_mn_ev,1)
    for m=1:size(E_mn_ev,2)
        if E_mn_ev(m,n)>0
            x=x_axis+E_01-E_mn_ev(m,n); % Determining the energy axis shift for each transition
            x_axises=[x_axises x];
        end
    end
end
for n=1:size(x_axises,2)
    for m=1:size(x_axises,1)
        if x_axises(m,n)<0
            x_axises(m,n)=-1;
        end
    end
end
 for n=1:size(x_axises,2)
    for m=1:size(x_axises,1)
        if x_axises(m,n)~=-1
            x_axises(m,n)= x_axises(m,1);
        end
    end
 end  
y_axises=[];
for n=1:size(EXP,1) % Setting up y-axis
    for m=1:size(EXP,2)
        if m==n            
            y=y_axis*EXP(m,n); % 1 at the diagonals are real, others are artificially generated by zeros matrix
            y_axises=[y_axises y];
        elseif m~=n && EXP(m,n)~=1
            y=y_axis*EXP(m,n); 
            y_axises=[y_axises y];
        end
    end
end
y_axises_final=y_axises;
for n=1:size(x_axises,2)
    for m=1:size(x_axises,1)
        if x_axises(m,n)<0
            y_axises_final(m,n)=0; %Setting crossection values coressponding to negative energy transitions as 0
        end
    end
end
Transition_m=[];
for n=1:size(Vn,1)
    for m=1:size(Vn,2)
        if Vn(m,n)>0
            Transition_m=[Transition_m Vn(m,n)]; %Final transitions m
        end
    end
end
n0=0;
Transition_n=[];
for i=1:size(Transition_m,2)
    if Transition_m(i)<21
        Transition_n= [Transition_n n0]; %n level
    elseif Transition_m(i)==21
        Transition_n= [Transition_n n0];
        n0=n0+1;
    end
end
Crossections=[Transition_n;Transition_m;x_axises;y_axises_final];
%------- Calculation of k_e_impact --------%
%Energy axis (x-axis) of EEDF should be exactly the same with the energy axis of Crossections
%EEDF (y-axis) should correspond to energy axis values of Crossections
EEDF_x = EEDF(:,1);
EEDF_y = EEDF(:,2);
EEDF_sigma=Crossections;
%Calculation of Crossections x EEDF
for m=1:size(Crossections,2)
for n=3:(size(Crossections,1)/2+1) % First 2 rows are only for indexation that's why it starts from 3, we only scan the Energy axis)
        if Crossections(n,m)>-1 && Crossections(n+22,m)>0
            if Crossections(n,m)>=EEDF_x(1) 
            dummy = interp1(EEDF_x,EEDF_y,Crossections(n,m))*Crossections(n+22,m);
            elseif Crossections(n,m)<=EEDF_x(1) % We have extrapolate for energy values smaller than EEDF_x(1)
                    dummy = interp1(EEDF_x,EEDF_y,Crossections(n,m),'linear','extrap')*Crossections(n+22,m);
            end
            if isnan(dummy)==0
            EEDF_sigma(n+22,m)= dummy;
            elseif isnan(dummy)==1
                EEDF_sigma(n+22,m)= 0;
            end 
            if EEDF_sigma(n+22,m)==0
                 EEDF_sigma(n,m)=0;
            end
        end
    end
end
EEDF_sigma(n,:)=0; %We equated all energy values > EEDF(max) to 0 because there is no corresponding EEDF value at this regime
k_e_int=[];   
 for m=1:size(EEDF_sigma,2)
 for n=3:(size(EEDF_sigma,1)/2 +1)
     if EEDF_sigma(n,m)>-1 && EEDF_sigma(n+22,m)>0
            dummy=[EEDF_sigma(n,m) EEDF_sigma(n+22,m)]
            k_e_int=[k_e_int; dummy]; %Setting up all of Energy vs Sigma x EEDF value for integration by removing zeros
            end
        end
 end
index =1e3; %indexing the integral range, index can be any artbitrary number that doesn't correspond to energy axis values 
k_e_impact=[];
s =[];
d=[];
z=[];
integral_sanity=[]; % To make sure correct things are integrated
for i=2:size(k_e_int,1) % Starting from 2 because I compare i with i-1, otherwise I will exceed array bounds
        if k_e_int(i,1)<k_e_int(i-1,1) & index==1e3
            dummy = [k_e_int(1:(i-1),1) k_e_int(1:(i-1),2)];
            dummy_int= dummy(:,1).*dummy(:,2); % --> E x (EEDF(E) x Sigma (E))
            integral_sanity=[integral_sanity; dummy(:,1) dummy_int(:,1)];
            k_e_impact=[k_e_impact trapz(dummy(:,1),dummy_int(:,1))];
            index =i;
        elseif k_e_int(i,1)<k_e_int(i-1,1) & index~=1e3;
            dummy = [k_e_int(index:(i-1),1) k_e_int(index:(i-1),2)];
            dummy2=size(k_e_int(index:(i-1),1),1);
            s = [s dummy2];
            dummy_int= dummy(:,1).*dummy(:,2);
            integral_sanity=[integral_sanity; dummy(:,1) dummy_int(:,1)];
            k_e_impact=[k_e_impact trapz(dummy(:,1),dummy_int(:,1))];
            index =i
        end
end
k_e_impact(end+1) = trapz(k_e_int(index:end,1),k_e_int(index:end,2).*k_e_int(index:end,1)); % Transition from 20-->21 was added in this step since loop size covers up to transition 19-->21
max_k_e_impact=max(C*k_e_impact)
Transition_n=[];
n0=0;
for i=2:size(k_e_impact,2) % Transition_n is revised since some transitions are not probable like 0-->21
    if k_e_impact(i)<k_e_impact(i-1)
        Transition_n=[Transition_n n0];
    elseif k_e_impact(i)>k_e_impact(i-1)
        Transition_n=[Transition_n n0];
        n0=n0+1
    end
end 
Transition_n=[Transition_n n0]; % loop doesn't cover the last point since it starts from 2 in order not to exceed the bounds
Transition_nm=Transition_n;
n0=1;
n=n0;
for i=2:size(k_e_impact,2)
    if k_e_impact(i)<k_e_impact(i-1)
        Transition_nm(i-1)= n;
        n=n+1;
       elseif k_e_impact(i)>k_e_impact(i-1)
         Transition_nm(i-1)= n;
         n=n0+1
         n0=n;
    end
end 
k_e_impact=[E_Td*ones(1,size(k_e_impact,2));Transition_n;Transition_nm;1e6*C*k_e_impact]'; % All calculated rate constants in cm3/s
   
      


    
    